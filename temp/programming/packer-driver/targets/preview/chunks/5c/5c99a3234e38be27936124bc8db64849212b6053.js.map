{"version":3,"sources":["file:///Users/yinshi/study/pfq/project/HeroClash/assets/src/utils/mutex.ts"],"names":["Mutex","VisibleError","ERROR_CODES","getInstance","instance","lock","resourceId","Promise","resolve","reject","locks","get","LOCK_FAILED","wasLocked","set","unlock","has","Map"],"mappings":";;;yDAGaA,K;;;;;;;;;;;;;;;;;;;;;;AAHJC,MAAAA,Y,iBAAAA,Y;AAAcC,MAAAA,W,iBAAAA,W;;;;;;;AAEvB;uBACaF,K,GAAN,MAAMA,KAAN,CAAY;AAMf;AACyB,eAAXG,WAAW,GAAU;AAC/B,cAAI,CAACH,KAAK,CAACI,QAAX,EAAqB;AACjBJ,YAAAA,KAAK,CAACI,QAAN,GAAiB,IAAIJ,KAAJ,EAAjB;AACH;;AAED,iBAAOA,KAAK,CAACI,QAAb;AACH,SAbc,CAef;;;AACaC,QAAAA,IAAI,CAACC,UAAD,EAAoC;AAAA;AACjD,mBAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpC;AACA,kBAAIT,KAAK,CAACU,KAAN,CAAYC,GAAZ,CAAgBL,UAAhB,CAAJ,EAAiC;AAC7B;AACAG,gBAAAA,MAAM,CAAC;AAAA;AAAA,kDAAiB;AAAA;AAAA,gDAAYG,WAA7B,mCAAyEN,UAAzE,wBAAD,CAAN;AACH,eALmC,CAOpC;;;AACA,kBAAMO,SAAS,GAAGb,KAAK,CAACU,KAAN,CAAYI,GAAZ,CAAgBR,UAAhB,EAA4B,IAA5B,EAAkCK,GAAlC,CAAsCL,UAAtC,CAAlB;;AACA,kBAAIO,SAAJ,EAAe;AACXL,gBAAAA,OAAO;AACV,eAFD,MAEO;AACHC,gBAAAA,MAAM,CAAC;AAAA;AAAA,kDAAiB;AAAA;AAAA,gDAAYG,WAA7B,mCAAyEN,UAAzE,wBAAD,CAAN;AACH;AACJ,aAdM,CAAP;AADiD;AAgBpD,SAhCc,CAkCf;;;AACOS,QAAAA,MAAM,CAACT,UAAD,EAA2B;AACpC,cAAI,CAACN,KAAK,CAACU,KAAN,CAAYM,GAAZ,CAAgBV,UAAhB,CAAL,EAAkC;AAC9B;AACH;;AACDN,UAAAA,KAAK,CAACU,KAAN,CAAYI,GAAZ,CAAgBR,UAAhB,EAA4B,KAA5B;AACH;;AAxCc,O;;AACf;AADSN,MAAAA,K,CAEMI,Q;AACf;AAHSJ,MAAAA,K,CAIMU,K,GAA8B,IAAIO,GAAJ,E","sourcesContent":["import { VisibleError, ERROR_CODES } from \"./errors\";\n\n// 互斥锁\nexport class Mutex {\n    // 互斥锁实例\n    private static instance: Mutex;\n    // 锁map\n    private static locks: Map<string, boolean> = new Map();\n\n    // 获取互斥锁单例\n    public static getInstance(): Mutex {\n        if (!Mutex.instance) {\n            Mutex.instance = new Mutex();\n        }\n\n        return Mutex.instance;\n    }\n\n    // 锁函数，使用资源ID进行加锁\n    public async lock(resourceId: string): Promise<void> {\n        return new Promise((resolve, reject) => {\n            // 如果已经加锁，直接报错\n            if (Mutex.locks.get(resourceId)) {\n                // 锁已经被占用，报错\n                reject(new VisibleError(ERROR_CODES.LOCK_FAILED, `Mutex lock failed: resource ${resourceId} is already locked`));\n            }\n\n            // 设置锁并检查是否成功\n            const wasLocked = Mutex.locks.set(resourceId, true).get(resourceId);\n            if (wasLocked) {\n                resolve();\n            } else {\n                reject(new VisibleError(ERROR_CODES.LOCK_FAILED, `Mutex lock failed: resource ${resourceId} is already locked`));\n            }\n        });\n    }\n\n    // 解锁函数\n    public unlock(resourceId: string): void {\n        if (!Mutex.locks.has(resourceId)) {\n            return;\n        }\n        Mutex.locks.set(resourceId, false);\n    }\n}"]}